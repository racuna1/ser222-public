#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 3
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\size huge
(SOLN)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Updated 4/21/2024
\end_layout

\begin_layout Standard
\align center

\size huge
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
NOT FOR STUDENT DISTRIBUTION OR DEMONSTRATION
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open one note card (3x5 inches).
 
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are 110 points available and the exam must be completed in 60 minutes.
 This exam has three types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Multiple choice questions:
\series default
 There are 35 points of multiple choice questions.
 An answer is selecting one option among the choices given.
 Each multiple choice is worth 2 to 5 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 30 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 5 or 10 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programing questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 45 points of write-in programming questions.
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
Please note that staff answers are very concise.
 Students would normally give longer explanations.
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Binary Search Trees
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Hashtables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Undirected Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Directed Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Binary Search Trees
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Undirected Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Directed Graphs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Symbol Tables & Binary Search Trees
\end_layout

\begin_layout Enumerate
[Acuña] Consider the following scenario: you need to store a record for
 each of the top 1000 teams that participated in a machine learning competition,
 in order to be able to look up which team placed in a specific place.
 Would it make more sense to use an array or a symbol table for this problem?
 Explain.
 [5 points] 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
FA19
\end_layout

\end_inset

 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
M03_01::LO2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
An array will probably be better.
 It will be faster and more efficient in storage.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
An array will probably be better.
 It will allow the team record type to be stored properly.
\end_layout

\begin_layout Enumerate
A symbol table will probably be better.
 It will provide more flexibility.
\end_layout

\begin_layout Enumerate
A symbol table will probably be better.
 It will be more efficient in storage.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following method discussed in lecture for deleting a node from
 a BST.
 What functionality is provided by the indicated line? [5 points] 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Acuna
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private Node delete(Node x, Key key) {
\end_layout

\begin_layout Plain Layout

    if (x == null) return null;
\end_layout

\begin_layout Plain Layout

    int cmp = key.compareTo(x.key);
\end_layout

\begin_layout Plain Layout

    if (cmp < 0) x.left = delete(x.left, key);
\end_layout

\begin_layout Plain Layout

    else if (cmp > 0) x.right = delete(x.right, key);
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

        if (x.right == null) return x.left;
\end_layout

\begin_layout Plain Layout

        if (x.left == null) return x.right;
\end_layout

\begin_layout Plain Layout

        Node t = x;
\end_layout

\begin_layout Plain Layout

        x = min(t.right);
\end_layout

\begin_layout Plain Layout

        x.right = deleteMin(t.right);
\end_layout

\begin_layout Plain Layout

        x.left = t.left;  //THIS LINE HERE
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    x.N = size(x.left) + size(x.right) + 1;
\end_layout

\begin_layout Plain Layout

    return x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Finds the in-order successor to x.
\end_layout

\begin_layout Enumerate
Replaces the current sub-tree rooted at x with the new sub-tree without
 the minimal node.
\end_layout

\begin_layout Enumerate
It sets the old left sub-tree of x to be a child of the successor node being
 moved up.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Updates the size variable of the tree rooted at x.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Hashtables
\end_layout

\end_deeper
\begin_layout Enumerate
Consider implementing a hashcode function for a string class.
 Which of the following statement(s) is/are True? Select all that apply.
 [5 points]
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Abraham
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
A hash function takes a string of arbitrary length and generates a fixed
 sized hash.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
A hash function takes a string of fixed length and generates a hash of variable
 size.
 
\end_layout

\begin_layout Enumerate
A hash function may give different hash values for identical strings.
 
\end_layout

\begin_layout Enumerate
None of the above are true.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Is the hashCode() implementation in the following Point2D class valid? That
 is, would a hashtable be able to properly store keys with this hashCode?
 Explain.
 [10 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC17 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Point2D {
\end_layout

\begin_layout Plain Layout

    public int x, y;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Point2D(int x, int y) { this.x = x; this.y = y;}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public int hashCode() {
\end_layout

\begin_layout Plain Layout

        return x % Integer.MAX_VALUE;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Yes - it implements the required hashCode method using the attributes in
 the class.
\end_layout

\begin_layout Enumerate
Yes - since MAX_VALUE is larger than any number, the modulus doesn't change
 the value of the point, and no information is lost.
\end_layout

\begin_layout Enumerate
No - different Point2Ds might have the same hashcode.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
No - it is missing the modulus by M.
\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Notes:
\end_layout

\begin_layout Standard
It does not encode the identity of the y member variable, and the modulus
 means that even objects with different x values may produce the same hash.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Imagine that you have a linear probe hashtable, with M=11.
 Draw the final hashtable after adding these keys: 34, 13, 10, 3, 0, 15,
 14.
 Use the hash function 
\begin_inset Formula $hash(k,i)=(k\;mod\;11+i)\;mod\;11$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is the number of times the algorithm has tried to insert the key.
 Your drawing should include the main size M array.
 [10 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC17 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 14cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Undirected Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
Consider using the DFS algorithm.
 From a performance standpoint, would it be better for the algorithm to
 use a Graph ADT implemented using an adjacency matrix or adjacency list?
 Explain.
 [5 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Acuna
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Adjacency matrix - it will provide faster support for visiting each of the
 adjacent nodes.
\end_layout

\begin_layout Enumerate
Adjacency matrix - it will provide faster support for checking if two nodes
 are connected.
\end_layout

\begin_layout Enumerate
Adjacency list - it will provide faster support for visiting each of the
 adjacent nodes.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
Adjacency list - it will provide faster support for checking if two nodes
 are connected.
\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Notes:
\series default
 It would be faster with an adjacency list.
 It only accesses the graph via the adj() method, which in an adjacency
 matrix is ~V, while in an adjacency list is ~degree(V).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In which of the following scenario(s) would you select using the DFS algorithm
 over BFS? Select all that apply.
 [5 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Abraham
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
You have limited memory available for storing intermediate results and you
 are given a wide graph.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
You need to find the optimal solution that is the shortest path for the
 given problem.
\end_layout

\begin_layout Enumerate
The solution is far away as in many levels away from the source node.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
When are you implementing a peer to peer network like a social networking
 site where you are attempting to find the degree of connection between
 two individuals.
 The degree of connection means the number of intermediate friend introductions
 you need in order to get to the required person.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Run the 
\series bold
BFS
\series default
 algorithm on this graph to compute the shortest paths between 0 and every
 other node.
 For reference, the BFS algorithm is shown below.
 Use the adjacency list above for the order of the nodes explored and follow
 the trace format shown before.
 Your answer must include the values of 
\emph on
v
\emph default
, 
\emph on
queue
\emph default
, and 
\emph on
edgeTo
\emph default
, as they update.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private void bfs(Graph G, int s) { //by Sedgewick.
 for reference.
\end_layout

\begin_layout Plain Layout

    Queue<Integer> queue = new LinkedList<>();
\end_layout

\begin_layout Plain Layout

    marked[s] = true;
\end_layout

\begin_layout Plain Layout

    queue.add(s);
\end_layout

\begin_layout Plain Layout

    while (!queue.isEmpty()) {
\end_layout

\begin_layout Plain Layout

        int v = queue.remove();
\end_layout

\begin_layout Plain Layout

        for (int w : G.adj(v))
\end_layout

\begin_layout Plain Layout

            if (!marked[w]) {
\end_layout

\begin_layout Plain Layout

                edgeTo[w] = v;
\end_layout

\begin_layout Plain Layout

                marked[w] = true;
\end_layout

\begin_layout Plain Layout

                queue.add(w);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Description
\begin_inset Graphics
	filename practice_exams/ser222_exercise11_graph1.png
	scale 50

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3, 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0, 4, 3, 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 0, 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 3, 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2, 4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Sample graph.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard

\series bold
Before loop:
\end_layout

\begin_layout Standard
marked[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
queue={
\begin_inset Formula $\;\;\;$
\end_inset

}
\end_layout

\begin_layout Standard

\series bold
Loop 1:
\end_layout

\begin_layout Standard
v=
\end_layout

\begin_layout Standard
edgeTo[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
edgeTo[
\begin_inset Formula $\;\;\;$
\end_inset

]=
\end_layout

\begin_layout Standard
queue = {
\begin_inset Formula $\;\;\;$
\end_inset


\begin_inset Formula $\;\;\;$
\end_inset


\begin_inset Formula $\;\;\;$
\end_inset

}
\end_layout

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
Staff Ans
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Before loop:
\end_layout

\begin_layout Standard
marked[0]=T
\end_layout

\begin_layout Standard
queue={0} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 1:
\end_layout

\begin_layout Standard
v=0
\end_layout

\begin_layout Standard
edgeTo[3]=0
\end_layout

\begin_layout Standard
edgeTo[1]=0
\end_layout

\begin_layout Standard
queue = {1, 3} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 2:
\end_layout

\begin_layout Standard
v = 3
\end_layout

\begin_layout Standard
edgeTo[4] = 4
\end_layout

\begin_layout Standard
queue = {4, 1} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 3:
\end_layout

\begin_layout Standard
v = 1
\end_layout

\begin_layout Standard
edgeTo[2]=1
\end_layout

\begin_layout Standard
queue={2, 4} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 4:
\end_layout

\begin_layout Standard
v = 4
\end_layout

\begin_layout Standard
edgeTo[5]=4
\end_layout

\begin_layout Standard
queue={5, 2} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 5:
\end_layout

\begin_layout Standard
v = 2
\end_layout

\begin_layout Standard
queue={5} (front)
\end_layout

\begin_layout Standard

\series bold
Loop 6:
\end_layout

\begin_layout Standard
v = 5
\end_layout

\begin_layout Standard
queue = {}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Directed Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
For the given directed graph, which of the following sequences is not a
 topological sort? [5 points]
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abraham
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_exam_practice_m12_topo.png
	scale 70

\end_inset


\end_layout

\begin_layout Enumerate
a, b, h, g, c, d, f, e
\end_layout

\begin_layout Enumerate
a, b, c, d, e, f, g, h 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
a, b, g, c, e, d, f, h
\end_layout

\begin_layout Enumerate
All of these are valid topological sorts.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
When using DFS to check for a cycle in a directed graph, can we simply check
 for the algorithm visiting a marked node? Answer yes or no and explain.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
No.
 It may be the case that there are multiple incoming edges to a node but
 no outgoing edges, in which it would become marked but since it's not possible
 to leave the node, it's not part of a cycle.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Binary Search Trees
\end_layout

\begin_layout Standard

\emph on
On the real exam, there could be programming questions on BSTs, hash tables,
 or graphs.
 They might be longer like Q11 or shorter like Q12.
\end_layout

\end_deeper
\begin_layout Enumerate
One of the data structures we studied is Binary Search Trees (BST).
 A simple implementation of a node for a binary tree is shown below.
 For this question, you are to implement a method called isBST that takes
 first node in a binary tree (its root) and returns true if it is the root
 of a BST, and false otherwise.
 Be careful with your syntax.
 [30 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

    private class Node {
\end_layout

\begin_layout Plain Layout

        public final Key key;
\end_layout

\begin_layout Plain Layout

        public Value val;
\end_layout

\begin_layout Plain Layout

        public Node left, right;
\end_layout

\begin_layout Plain Layout

        public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

            this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    private static boolean isBST(Node root) {
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 12cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private class Node {
\end_layout

\begin_layout Plain Layout

  public final Key key;
\end_layout

\begin_layout Plain Layout

  public Value val;
\end_layout

\begin_layout Plain Layout

  public Node left, right;
\end_layout

\begin_layout Plain Layout

  public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

      this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public static boolean isBST(Node root, ) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public static boolean isBST(Node root) {
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root == null)
\end_layout

\begin_layout Plain Layout

    return true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root.left != null && root.left.key >= root.key)
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(root.right != null && root.right.key <= root.key)
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return isBST(root.left) && isBST(root.right);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

private class Node {
\end_layout

\begin_layout Plain Layout

    public final Key key;
\end_layout

\begin_layout Plain Layout

    public Value val;
\end_layout

\begin_layout Plain Layout

    public Node left, right;
\end_layout

\begin_layout Plain Layout

    public int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Node(Key key, Value val, int N) {
\end_layout

\begin_layout Plain Layout

        this.key = key; this.val = val; this.N = N;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//UGTA Cole: There are many ways to solve this problem.
\end_layout

\begin_layout Plain Layout

public boolean isBST(Node root) {
\end_layout

\begin_layout Plain Layout

    List<Integer> nodeVals = new ArrayList<>();
\end_layout

\begin_layout Plain Layout

    inOrder(root, nodeVals);
\end_layout

\begin_layout Plain Layout

    return isSorted(nodeVals);    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

private void inOrder(Node node, List<Integer> vals){
\end_layout

\begin_layout Plain Layout

    if(node == null) return;
\end_layout

\begin_layout Plain Layout

    inOrder(node.left, vals);
\end_layout

\begin_layout Plain Layout

    vals.add(node.val);
\end_layout

\begin_layout Plain Layout

    inOrder(node.right, vals);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

private boolean isSorted(List<Integer> vals){
\end_layout

\begin_layout Plain Layout

    long lastVal = Long.MIN_VALUE;
\end_layout

\begin_layout Plain Layout

    for(Integer x : vals){
\end_layout

\begin_layout Plain Layout

        if(x <= lastVal) return false;
\end_layout

\begin_layout Plain Layout

        lastVal = x;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Directed Graphs
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Implement
\series default
 a method to compute the average out-degree of nodes with at least one out-edge;
 use the method signature below.
 The out-degree of a node is the number of outgoing edges it has.
 Assume you are using the standard Directed Graph ADT discussed in class
 (see API below).
 You may not import any packages.
 Creating additional helper methods is fine but you should provide a one
 line comment that indicates their purpose.
 As an example, the following graph would have an average out-degree of
 1.
 If there was an extra node unconnected to anything, it would still be 1.
 [15 points] 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Core2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_04_02_core2_graph_simple.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_03_02_api_digraph.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double averageOutDegree(Digraph G) {
\end_layout

\begin_layout Plain Layout

    
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double averageOutDegree(Digraph G) {
\end_layout

\begin_layout Plain Layout

  double sum;
\end_layout

\begin_layout Plain Layout

  int nodes;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for(int v = 0; v < G.V(); v++) {
\end_layout

\begin_layout Plain Layout

    int deg = 0
\end_layout

\begin_layout Plain Layout

    for(Integer i : G.adj(v))
\end_layout

\begin_layout Plain Layout

      deg++;
\end_layout

\begin_layout Plain Layout

    if(deg > 0) {sum += deg; nodes++;}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return sum / nodes;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Extra Questions
\end_layout

\begin_layout Standard
The following questions were used on previous practice exams.
 They may use content not covered in the current semester but are provided
 for additional practice.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset

Short Answer: Symbol Tables & Binary Search Trees
\series default

\begin_inset Note Note
status collapsed

\begin_layout Enumerate
[Acuña] Trace an initially empty symbol table (called ST) through the following
 operations:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SymbolTable<> ST = new BinarySearchTree<String, Integer>();
\end_layout

\begin_layout Plain Layout

ST.put("CSE110", 150);
\end_layout

\begin_layout Plain Layout

ST.put("CSE205", 150);
\end_layout

\begin_layout Plain Layout

ST.put("CSE230", 100);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 100);
\end_layout

\begin_layout Plain Layout

System.out.println(ST.get("CSE205"));
\end_layout

\begin_layout Plain Layout

ST.put("CSE205", 250);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 75);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Give the contents of the symbol table after the code has been executed.
 Use the format ABC### : ### (e.g., 
\begin_inset Quotes eld
\end_inset

CSE110 : 150
\begin_inset Quotes erd
\end_inset

) to give your answer.
 Use separate lines for each key/value pair.
 [10 points]
\end_layout

\begin_layout Plain Layout
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SER100 : 150
\end_layout

\begin_layout Plain Layout

SER200 : 250
\end_layout

\begin_layout Plain Layout

SER250 : 100
\end_layout

\begin_layout Plain Layout

SER316 : 75
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Enumerate
Consider the task of implementing a SymbolTable vs an OrderedSymbolTable.
 For the purposes of get and put, which you be more likely to create an
 efficient implementation for? Explain.
 (Hint: no knowledge of BSTs or hash tables is needed.) [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 2.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
OrderedSymbolTable offers more potential for optimization since it means
 you have some structure (i.e., all elements are Comparable) on the data which
 you can exploit.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Trace a (non-balancing) BST through the following operations:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename practice_exams/ser222_17f_bst.png
	scale 250

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//assume that the "tree" variable below has already been constructed,
\end_layout

\begin_layout Plain Layout

//per the tree shown above.
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(3));
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(7));
\end_layout

\begin_layout Plain Layout

tree.add(new Integer(2));
\end_layout

\begin_layout Plain Layout

tree.remove(new Integer(6));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Draw the structure of the BST after each call.
 Images must be cumulative.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 14cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_exam3_practice_q1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
When adding and removing nodes from a heap, the tree structure will always
 remain balanced.
 Why is it the case that when these operations are performed over a BST,
 there is a chance that the tree will become unbalanced? [5 points] 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Acuna
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
In a BST there is exactly one place a node may be added.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
In a BST nodes are always placed in level nearest to the root node.
\end_layout

\begin_layout Enumerate
Because heaps use an array, while BSTs use a linked node structured.
\end_layout

\begin_layout Enumerate
This is is a trick question, both BSTs and heaps are always balanced.
\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
Staff Notes:
\series default
 In a BST, there is exactly one place a node may be added.
 This position might be selected such that a stilted tree is formed (ex:
 consider adding elements in sequence).
 In a heap, a node may end up in different places since although it is added
 to the 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

 position, swim is used to move it upward to a valid position.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Undirected Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
If you are asked to run a DFS or BFS by hand, and given a picture of the
 graph, and the code for the algorithm, why is there a chance you and a
 classmate who correctly execute the algorithm will produce different paths?
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 2.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
The order in which you explore outward from a particular node is dependent
 on the order returned by the adj() method.
 Without a rule, or an adjacency list, the order of the neighbors you each
 choose to explore may be different.
 It may also be the case that you start from a different node, which may
 lead to an entirely different exploration of the graph.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Directed Graphs
\end_layout

\end_deeper
\begin_layout Enumerate
In the DFS based topological sort, what would happen if nodes were pushed
 on the stack before their children were explored, rather than after? Would
 the algorithm still work? Explain.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Staff Ans:
\end_layout

\begin_layout Standard
No.
 We lose the logic which makes sure that a node is only listed after its
 children have been listed, which, in reverse, gives us the topological
 sort solution.
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Dijkstra’s Algorithm will work for both negative and positive weights? [5
 points]
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abraham
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
True, as long as there is no negative weight cycle, Dijkstra’s can find
 the shortest paths.
\end_layout

\begin_layout Enumerate
True, because Dijkstra’s will just update the weights and add the maximum
 negative weight to each edge to find the shortest path.
\end_layout

\begin_layout Enumerate
False, because Dijkstra’s algorithms will select an edge with minimum distance
 in every stage and negative weights might change the cost on nodes in a
 way that it invalidates other paths that use that node.
 
\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
False, because the problem of finding shortest path cannot be solved for
 graphs with negative weights.
\end_layout

\end_deeper
\end_inset


\end_layout

\end_deeper
\end_body
\end_document
