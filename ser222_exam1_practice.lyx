#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 1 
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\size huge
(SOLN)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Updated 9/22/2021
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open one note card (3x5 inches).
  
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are TODO points available and the exam must be completed in 35 minutes.
 This exam has three types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Multiple choice questions:
\series default
 There are 45 points of multiple choice questions.
 An answer is selecting one option among the choices given.
 Each multiple choice is worth 2 to 5 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 20 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 5 or 10 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 25 points of write-in programming questions.
\end_layout

\begin_layout Standard
\begin_inset VSpace 8cm
\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Data Abstraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Stacks, Lists, and Generics
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Analysis of Algorithms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Analysis, Design, and Justification I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Stacks, Lists, and Generics
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset

Short Answer: Data Abstraction
\end_layout

\begin_layout Enumerate
When would it make the most sense for the Point2D class to use polar coordinates
 for its internal representation? [5 points] 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
from FA19 exam
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
When fast trigonometry functions are available.
\end_layout

\begin_layout Enumerate
When the polar coordinates accessor and mutator methods will be used most
 often.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
When the API provides both Cartesian and polar coordinate methods.
\end_layout

\begin_layout Enumerate
It never ever matters!
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Given the following piece of code which of the following statements is correct?
 [5 points] 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abraham
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public interface Numbers { 
\end_layout

\begin_layout Plain Layout

int count();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface Characters { 
\end_layout

\begin_layout Plain Layout

int length(); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public abstract class NaturalNumbers implements Numbers { 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Alphabets extends NaturalNumbers implements Characters { 
\end_layout

\begin_layout Plain Layout

    @Override public int count() { }
\end_layout

\begin_layout Plain Layout

    @Override public int length() { } 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
This code will not compile, because method count() in interface Numbers
 must be defined abstract.
\end_layout

\begin_layout Enumerate
This code will not compile, because class NaturalNumbers must implement
 method count() from interface Numbers.
\end_layout

\begin_layout Enumerate
This code will not compile, because the same class cannot extend a class
 and implement another interface at the same time
\end_layout

\begin_layout Enumerate
This code will compile without errors.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
When it comes to functionality (not performance), is it important to know
 how an ADT is internally implemented? Explain.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 The point of an ADT is that it is an abstraction where the internal representat
ion is hidden.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Stacks, Lists, and Generics
\end_layout

\end_deeper
\begin_layout Enumerate
Consider an implementation of unsorted singly linked list.
 Suppose it has a representation with a head and a tail pointer, where head's
 next leads to tail.
 Given this representation, which of the following operation cannot be implement
ed in O(1) time? [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
Insertion before the head node of the linked list.
\end_layout

\begin_layout Enumerate
Insertion after the tail node of the linked list.
\end_layout

\begin_layout Enumerate
Deletion of the head node of the linked list.
\end_layout

\begin_layout Enumerate
Deletion of the tail node of the linked list.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Assume that we are storing the ASU IDs of 50 students in a singly linked
 list.
 Due to a security breach, one entire node has been corrupted in the middle.
 In this case, will all the 50 nodes still be accessible to us? [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
Yes - the Java garbage collector will delete the bad node from the list.
 
\end_layout

\begin_layout Enumerate
Yes - although we do not have a previous reference, we can use the tail
 reference.
\end_layout

\begin_layout Enumerate
No – any nodes that follow the corrupted node will be inaccessible.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
No - the entire list will be lost and the data will be inaccessible.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Analysis of Algorithms
\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following growth function: [5 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $f_{1}(n)=100+10log(n)n^{2}+45n$
\end_inset


\end_layout

\begin_layout Standard
What is the Big-Oh order of this function? You should provide a relatively
 tight upper bound (e.g., not just 
\begin_inset Formula $2^{n}$
\end_inset

).
\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n^{3})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n^{2}log(n))$
\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(nlog(n))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n^{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(log(n))$
\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Prove that your bound holds.
 (Hint: the definition for Big-Oh is 
\begin_inset Formula $𝑓(𝑛)=𝑂(𝑔(𝑛))$
\end_inset

 iff 
\begin_inset Formula $|f(n)|≤𝑐|𝑔(𝑛)|$
\end_inset

 (for 
\begin_inset Formula $n>x_{0}$
\end_inset

, where 
\begin_inset Formula $x_{0}$
\end_inset

 is a constant, and 
\begin_inset Formula $c$
\end_inset

 is also a constant).
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
Ans:
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the Big-Oh order of the following code fragment? The fragment is
 parametrized on the variable 
\begin_inset Formula $n$
\end_inset

.
 Assume that you are measuring the number of println calls.
 You should provide a relatively tight upper bound (e.g., not just 
\begin_inset Formula $2^{n}$
\end_inset

).
 [5 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

for (int i = 1; i <= n; i++)
\end_layout

\begin_layout Plain Layout

  for (int j = 1; j <= n; j *= 10)
\end_layout

\begin_layout Plain Layout

    System.out.println("Nested loops!");
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n^{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n^{2}logn)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(nlogn)$
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $O(n)$
\end_inset


\end_layout

\begin_layout Enumerate
Does not exist.
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Analysis, Design, and Justification I
\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Consider the following problem, and categorize it according to the
 different axis of problem complexity: find the moves to win a game of chess
 with standard rules.
 [5 points] 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
SC20
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Open-ended, Well-defined
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Open-ended, Ill-defined
\end_layout

\begin_layout Enumerate
Close-ended, Well-defined
\end_layout

\begin_layout Enumerate
Close-ended, Ill-defined
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Vega] Consider the following problem function.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static int sum_all(int n) {
\end_layout

\begin_layout Plain Layout

	int sum = 0;
\end_layout

\begin_layout Plain Layout

    for(int i = 0; i < n; i++)
\end_layout

\begin_layout Plain Layout

        sum += i;	// Cost metric
\end_layout

\begin_layout Plain Layout

    return sum;
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose you were asked to find the Big-Oh of the function using the cost
 metric shown.
 What type of problem is this.
 [5 points]
\end_layout

\begin_layout Enumerate
Structured
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Semi-structureed
\end_layout

\begin_layout Enumerate
Unstructured
\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
The question is structured because it is explicitly stated what the problem
 is, and we are given a specific cost metric.
 If the cost metric was not given, then we would have to choose a cost metric
 ourselves, which would make the question semi-structured.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Vega] Suppose you are given the following problem:
\end_layout

\begin_deeper
\begin_layout Standard
Problem: Consider designing a program that reads a list of IDs from the
 user and then sorts them and prints them all back to the user.
\end_layout

\begin_layout Standard
Create an Analysis of this problem by identifying any ill-defined parts
 of the problem, making reasonable assumptions for each (if possible), and
 identifying any important metrics.
 Justify any assumptions you make.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
Ill-defined parts:
\end_layout

\begin_layout Standard
- What programming language should we use?
\end_layout

\begin_layout Standard
- What sorting order should we use?
\end_layout

\begin_layout Standard
Assumptions:
\end_layout

\begin_layout Standard
- We will is the Java programming language.
 Java is the main programming language used in SER222
\end_layout

\begin_layout Standard
- We will use least-to-greatest sorting.
 This part is unerspecified and would require more clarification, but we
 will assume it is from least-to-greatest
\end_layout

\begin_layout Standard
Metrics
\end_layout

\begin_layout Standard
- Big-Oh of the sorting algorithm used
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Stacks, Lists, and Generics
\end_layout

\begin_layout Standard

\emph on
The real exam will involve writing code for one or more methods.
 Methods typically contain ~20 lines and have a higher weight (20-30 points)
 than other questions.
 The problem given here uses linked lists but all modules with programming
 concepts are fair game (data abstraction, stacks/lists/generic, elementary
 sorting).
\end_layout

\begin_layout Standard
Linked lists are a very typical data structure used in ADTs like stacks,
 or queues.
 For this question, implement the list operation shown below: cloneTail.
 The list is singly linked, and you only start with a reference to it's
 head (not tail).
 The LinearNode class may be used, but you may not import any packages.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public class LinearNode<T> {
\end_layout

\begin_layout Plain Layout

  private LinearNode<T> next;
\end_layout

\begin_layout Plain Layout

  public T element;
\end_layout

\begin_layout Plain Layout

  public LinearNode(T elem) { next = null; element = elem; }
\end_layout

\begin_layout Plain Layout

  public LinearNode<T> getNext() { return next; } 
\end_layout

\begin_layout Plain Layout

  public void setNext(LinearNode<T> node) { next = node; } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Given the head of a singly linked list, creates and links together a
\end_layout

\begin_layout Plain Layout

//clone of the list starting at a specific node (identified by index).
\end_layout

\begin_layout Plain Layout

//Input list will be always non-empty.
 Returns head of new list.
\end_layout

\begin_layout Plain Layout

//Assume that the start index given will always be valid.
\end_layout

\begin_layout Plain Layout

//EXAMPLES: cloneTail([A, B, C], 2) returns [C],
\end_layout

\begin_layout Plain Layout

//          cloneTail([A, B, C], 1) returns [B, C],
\end_layout

\begin_layout Plain Layout

//          cloneTail([A], 0) returns [A],
\end_layout

\begin_layout Plain Layout

//          where brackets show the contents of the list at a high level
\end_layout

\begin_layout Plain Layout

//          and the left most node is the head.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public LinearNode cloneTail(LinearNode head, int start) {
\end_layout

\begin_layout Plain Layout

  //TODO: implement this method.
 creating additional helpers is fine.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public class LinearNode<T> {
\end_layout

\begin_layout Plain Layout

  private LinearNode<T> next;
\end_layout

\begin_layout Plain Layout

  public T element;
\end_layout

\begin_layout Plain Layout

  public LinearNode(T elem) { next = null; element = elem; }
\end_layout

\begin_layout Plain Layout

  public LinearNode<T> getNext() { return next; } 
\end_layout

\begin_layout Plain Layout

  public void setNext(LinearNode<T> node) { next = node; } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Given the head of a singly linked list, creates and links together a
\end_layout

\begin_layout Plain Layout

//clone of the list starting at a specific node (identified by index).
\end_layout

\begin_layout Plain Layout

//Input list will be always non-empty.
 Returns head of new list.
\end_layout

\begin_layout Plain Layout

//Assume that the start index given will always be valid.
\end_layout

\begin_layout Plain Layout

//EXAMPLES: cloneTail([A, B, C], 2) returns [C],
\end_layout

\begin_layout Plain Layout

//          cloneTail([A, B, C], 1) returns [B, C],
\end_layout

\begin_layout Plain Layout

//          cloneTail([A], 0) returns [A],
\end_layout

\begin_layout Plain Layout

//          where brackets show the contents of the list at a high level
\end_layout

\begin_layout Plain Layout

//          and the left most node is the head.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public LinearNode cloneTail(LinearNode head, int start) {
\end_layout

\begin_layout Plain Layout

  //TODO: implement this method.
 creating additional helpers is fine.
\end_layout

\begin_layout Plain Layout

    LinearNode newHead, newTail;
\end_layout

\begin_layout Plain Layout

  int depth = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  while(depth != start) {
\end_layout

\begin_layout Plain Layout

    depth++;
\end_layout

\begin_layout Plain Layout

    head=head.getNext();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  newHead = new LinearNode(head.getElement());
\end_layout

\begin_layout Plain Layout

  newTail = newHead;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  head = head.getNext();  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  while(head != null)
\end_layout

\begin_layout Plain Layout

    LinearNode node = new LinearNode(head.getElement());
\end_layout

\begin_layout Plain Layout

    newTail.setNext(node);
\end_layout

\begin_layout Plain Layout

    newTail = node;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    head = head.getNext();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return newHead;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part*
Extra Questions
\end_layout

\begin_layout Standard
The following questions were used on previous practice exams - they are
 not part of the practice exam, and may use content not covered in the current
 semester, but are provided for additional practice.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset


\begin_inset Formula $ $
\end_inset

Short Answer: Data Abstraction
\end_layout

\begin_layout Enumerate
Consider the following constructor for an immutable matrix ADT:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public class SolnMatrix implements Matrix { 
\end_layout

\begin_layout Plain Layout

    private final int[][] data;
\end_layout

\begin_layout Plain Layout

    public SolnMatrix(int[][] matrix) {
\end_layout

\begin_layout Plain Layout

        data = matrix
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // the usual operations follow...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Will this class behave as expected? Explain.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 It performs a shallow copy of the 2D matrix so if it is changed outside,
 it will be changed in this object.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Stacks, Lists, and Generics
\end_layout

\end_deeper
\begin_layout Enumerate
Assume that 
\emph on
head
\emph default
 is the head node of a singly linked list containing the nodes A, B, and
 C.
 What would the result of executing the following code be? Draw the resulting
 list using box and arrow notation and include any variables.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

head.getNext().getNext().setNext(head.getNext());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What would be the difference in memory usage for storing a thousand elements
 in an array vs a linked list? Which takes less space? Explain.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
An array would take less.
 A linked list must also store the next reference in addition to each data
 element.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
If you were optimizing for performance and wanted to support potentially
 adding many new elements to a data structure, would an array or linked
 list be more appropriate? Explain using Big-Oh.
 [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
A linked list would be more appropriate.
 It's possible to add to a list in constant time (i.e., O(1)) without having
 to shift around the existing elements in O(n) time, like an array would
 need.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Analysis of Algorithms
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Consider the following algorithm that implements linear search:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static boolean find(int target, int[] pool) {
\end_layout

\begin_layout Plain Layout

    for(int i = 0; i < pool.length; i++)
\end_layout

\begin_layout Plain Layout

        if(pool[i] == target)
\end_layout

\begin_layout Plain Layout

            return true;
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
If you were asked to analyze the performance of this algorithm, would it
 be useful to write a growth function that counts the number of times the
 return false statement will execute? That is, use the number of returns
 as the cost metric.
 Explain.
 [8 points]
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_deeper
\end_inset

Consider the following method, excerpted from a protein structural prediction
 algorithm.
 Assume that any variables not given as parameters are available as globals.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

//sets initial interaction energy.
\end_layout

\begin_layout Plain Layout

//  int n: dimension of square matrix storing protein backbone.
\end_layout

\begin_layout Plain Layout

//  double[][] pair: energy matrix.
\end_layout

\begin_layout Plain Layout

void energy() {
\end_layout

\begin_layout Plain Layout

    double ee = 0; 
\end_layout

\begin_layout Plain Layout

    //reset all pair interaction energies to zero.
\end_layout

\begin_layout Plain Layout

    for(int j = 1; j < n; j++)
\end_layout

\begin_layout Plain Layout

        for(int i = 3; i < n-2; i++)
\end_layout

\begin_layout Plain Layout

            pair[i][j] = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //<more code follows in actual program>
\end_layout

\begin_layout Plain Layout

    //...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give a growth function for 
\emph on
md_fragment
\emph default
 that counts the number of assignments in the inner loop based on 
\emph on
n
\emph default
.
 [5 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Formula $f(n)=\Sigma_{j=1}^{n}\Sigma_{i=3}^{n-2}1$
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following algorithm that implements linear search:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static boolean find(int target, int[] pool) {
\end_layout

\begin_layout Plain Layout

    for(int i = 0; i < pool.length; i++)
\end_layout

\begin_layout Plain Layout

        if(pool[i] == target)
\end_layout

\begin_layout Plain Layout

            return true;
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you were asked to analyze the performance of this algorithm, would it
 be useful to write a growth function that counts the number of times the
 return false statement will execute? That is, use the number of returns
 as the cost metric.
 Explain.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_deeper
\end_body
\end_document
