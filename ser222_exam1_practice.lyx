#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 1 
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\size huge
(SOLN)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Updated 5/14/2019
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open textbook (Algorithms 4e by Sedgewick and Wayne), as well
 as open note.
 
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are 96 points available and the exam must be completed in 37.5 minutes.
 This exam has two types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 64 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 4 or 8 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Write-in questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 32 points of write-in programming questions.
\end_layout

\begin_layout Standard
\begin_inset VSpace 10cm
\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Recursion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Data Abstraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Stacks, Lists, and Generics
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA: Analysis of Algorithms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Recursion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Analysis of Algorithms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Recursion
\end_layout

\begin_layout Enumerate
Consider an algorithm for determining the size of some nested folders/files
 recursively.
 (Imagine right clicking an item on your desktop and viewing it's size.)
 What would be the base case(s) for this problem? [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
An empty folder, or a folder containing only files.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Consider the problem of reversing letters of a string.
 Would it be more appropriate to use recursion or iteration? Justify your
 answer.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
(Answer would be evaluated on justification's soundness.
 Full credit answers for either direction are possible.)
\end_layout

\begin_layout Standard
Either would work okay but iteration would probably be faster since it doesn't
 require the overhead of many recursive calls.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Data Abstraction
\end_layout

\end_deeper
\begin_layout Enumerate
When it comes to functionality (not performance), is it important to know
 how an ADT is internally implemented? Explain.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 The point of an ADT is that it is an abstraction where the internal representat
ion is hidden.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following constructor for an immutable matrix ADT:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public class SolnMatrix implements Matrix { 
\end_layout

\begin_layout Plain Layout

    private final int[][] data;
\end_layout

\begin_layout Plain Layout

    public SolnMatrix(int[][] matrix) {
\end_layout

\begin_layout Plain Layout

        data = matrix
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // the usual operations follow...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Will this class behave as expected? Explain.
 [8 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
No.
 It performs a shallow copy of the 2D matrix so if it is changed outside,
 it will be changed in this object.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Stacks, Lists, and Generics
\end_layout

\end_deeper
\begin_layout Enumerate
Assume that 
\emph on
head
\emph default
 is the head node of a singly linked list containing the nodes A, B, and
 C.
 What would the result of executing the following code be? Draw the resulting
 list using box and arrow notation and include any variables.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

head.getNext().getNext().setNext(head.getNext());
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename practice_exams/ser222_exam1_practice_q5.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What would be the difference in memory usage for storing a thousand elements
 in an array vs a linked list? Which takes less space? Explain.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
An array would take less.
 A linked list must also store the next reference in addition to each data
 element.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
If you were optimizing for performance and wanted to support potentially
 adding many new elements to a data structure, would an array or linked
 list be more appropriate? Explain using Big-Oh.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
A linked list would be more appropriate.
 It's possible to add to a list in constant time (i.e., O(1)) without having
 to shift around the existing elements in O(n) time, like an array would
 need.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Analysis of Algorithms
\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following growth function: [16 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $f_{1}(n)=100+10log_{10}(n)n^{2}+45n$
\end_inset


\end_layout

\begin_layout Standard
What is the Big-Oh order of this function? You should provide a relatively
 tight upper bound.
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Formula $O(log_{10}(n)n^{2})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Prove that your bound holds.
 (Hint: the definition for Big-Oh is 
\begin_inset Formula $ùëì(ùëõ)=ùëÇ(ùëî(ùëõ))$
\end_inset

 iff 
\begin_inset Formula $|f(n)|‚â§ùëê|ùëî(ùëõ)|$
\end_inset

 (for 
\begin_inset Formula $n>x_{0}$
\end_inset

, where 
\begin_inset Formula $x_{0}$
\end_inset

 is a constant, and 
\begin_inset Formula $c$
\end_inset

 is also a constant).
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
Ans:
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the Big-Oh order of the following code fragment? The fragment is
 parametrized on the variable 
\begin_inset Formula $n$
\end_inset

.
 Assume that you are measuring the number of println calls.
 [8 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

for (int i = 1; i <= n; i++)
\end_layout

\begin_layout Plain Layout

  for (int j = 1; j <= n; j *= 10)
\end_layout

\begin_layout Plain Layout

    System.out.println("Nested loops!");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Formula $O(nlogn)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Consider the following algorithm that implements linear search:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static boolean find(int target, int[] pool) {
\end_layout

\begin_layout Plain Layout

    for(int i = 0; i < pool.length; i++)
\end_layout

\begin_layout Plain Layout

        if(pool[i] == target)
\end_layout

\begin_layout Plain Layout

            return true;
\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
If you were asked to analyze the performance of this algorithm, would it
 be useful to write a growth function that counts the number of times the
 return false statement will execute? That is, use the number of returns
 as the cost metric.
 Explain.
 [8 points]
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
N/A Programming: Recursion
\end_layout

\end_deeper
\begin_layout Enumerate
Implement a recursive method called 
\series bold
countOccurrences
\series default
 that takes the first node in a singly linked list and returns the number
 of times a particular value occurs in the list.
 For example, if countOccurrences("A") is called on a list with nodes containing
: "A", "B", "C", "B", "E", it would return 1.
 If countOccurrences("B") was called on the same list, it would return 2.
 For reference, a standard implementation for the nodes of a singly linked
 list is given below.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Source: MT Fall 2017.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class LinearNode<T> {
\end_layout

\begin_layout Plain Layout

  private LinearNode<T> next;
\end_layout

\begin_layout Plain Layout

  private T element;
\end_layout

\begin_layout Plain Layout

  public LinearNode(T elem) { next = null; element = elem; }
\end_layout

\begin_layout Plain Layout

  public LinearNode<T> getNext() { return next; } 
\end_layout

\begin_layout Plain Layout

  public void setNext(LinearNode<T> node) { next = node; } 
\end_layout

\begin_layout Plain Layout

  public T getElement() { return element; } 
\end_layout

\begin_layout Plain Layout

  public void setElement(T elem) { element = elem; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Using the fantastic four approach, determine the size n problem for the
 method countOccurrences.
 [2 point]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
Finding the total number of times a value occurs in the whole list.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.75cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Identify the stopping condition(s) and the return value, if any, for the
 problem.
 [2 point]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
Ans:
\end_layout

\begin_layout Standard
An empty list, for which zero will be returned.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.75cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Determine the size m problem(i.e.
 the ‚Äúsub-problem‚Äù) for the problem.
 [2 point]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
Finding the total number of times a value occurs in the tail of the list
 (i.e., search everything after the first node).
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.75cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
How is the size-n problem constructed from the size m problem? [2 point]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
Add the sub-problem count to 1 if the head has a match, otherwise add 0.
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.75cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Implement the recursive method 
\series bold
public static int countOccurrences<T>(LinearNode node, T target)
\series default
 (Hint: use .equals to compare the target with the contents of each node.)
 [16 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static int countOccurrences<T>(LinearNode node, T target) {
\end_layout

\begin_layout Plain Layout

  if(node == null)
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if(node.element.equals(target))
\end_layout

\begin_layout Plain Layout

    return 1 + countOccurrence(node.getNext(), target);
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    return countOccurrence(node.getNext(), target);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Stacks, Lists, and Generics
\end_layout

\begin_layout Standard

\emph on
If this was the real exam, there might be a question here asking you to
 implement methods (potentially stand-alone, or in an ADT) using linked
 lists.
\end_layout

\begin_layout Standard

\series bold
Programming: Analysis of Algorithms
\end_layout

\end_deeper
\begin_layout Enumerate
Consider the following method, excerpted from a protein structural prediction
 algorithm.
 Assume that any variables not given as parameters are available as globals.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

//sets initial interaction energy.
\end_layout

\begin_layout Plain Layout

//  int n: dimension of square matrix storing protein backbone.
\end_layout

\begin_layout Plain Layout

//  double[][] pair: energy matrix.
\end_layout

\begin_layout Plain Layout

void energy() {
\end_layout

\begin_layout Plain Layout

    double ee = 0; 
\end_layout

\begin_layout Plain Layout

    //reset all pair interaction energies to zero.
\end_layout

\begin_layout Plain Layout

    for(int j = 1; j < n; j++)
\end_layout

\begin_layout Plain Layout

        for(int i = 3; i < n-2; i++)
\end_layout

\begin_layout Plain Layout

            pair[i][j] = 0.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //<more code follows in actual program>
\end_layout

\begin_layout Plain Layout

    //...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give a growth function for 
\emph on
md_fragment
\emph default
 that counts the number of assignments in the inner loop based on 
\emph on
n
\emph default
.
 [8 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset Formula $f(n)=\Sigma_{j=1}^{n}\Sigma_{i=3}^{n-2}1$
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
