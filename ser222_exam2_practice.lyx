#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size huge
SER 222 
\series bold
Practice
\series default
 Exam 2
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\size huge
(SOLN)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
Updated 9/6/2021
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Last Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{6cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First Name: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{5.94cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Last 4 digits of ASU ID: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rule{4.05cm}{0.15mm}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\align center
Exam Instructions
\end_layout

\begin_layout Standard
The exam is open one note card (3x5 inches).
 
\bar under
No electronic items are allowed.
 Write legibly.

\bar default
 Please use a pen (instead of a pencil) if you have one.
 There are 115 points available and the exam must be completed in 37.5 minutes.
 This exam has three types of questions:
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Multiple choice questions:
\series default
 There are 35 points of multiple choice questions.
 An answer is selecting one option among the choices given.
 Each multiple choice is worth 2.5 to 5 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short answer questions:
\series default
 There are 40 points of short answer questions.
 A typical answer is one or two sentences.
 Each short answer question is worth 10 points.
\end_layout

\begin_layout Standard
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming questions:
\series default
 The programming questions are given near the end of the paper.
 They must be answered on the question paper.
 There are 20 points of write-in programming questions.
\end_layout

\begin_layout Standard
\begin_inset VSpace 8cm
\end_inset


\end_layout

\begin_layout Standard
\align right
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Topic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Earned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Elemenary Sorts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Mergesort
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Priority Queues
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Symbol Tables
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MC/SA: Analysis, Design, and Justification II
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prog: Priority Queues
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
115
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Elementary Sorts
\end_layout

\begin_layout Enumerate
[Abraham] Which sorting algorithm will take least time when all elements
 of input array are identical? Consider the implementations of the sorting
 algorithms as given in class.
 [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
Selection Sort
\end_layout

\begin_layout Enumerate
Insertion Sort 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Shell Sort
\end_layout

\begin_layout Enumerate
Merge Sort
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] When dealing with systems having low RAM capacity, or analyzing
 large datasets, space is at a premium.
 In these cases, algorithms must be designed to reduce their memory foot
 print.
 From the sorting algorithm implementations seen in class, which would be
 the worse choice? [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
Selection Sort
\end_layout

\begin_layout Enumerate
Insertion Sort
\end_layout

\begin_layout Enumerate
Shell Sort
\end_layout

\begin_layout Enumerate
Merge Sort 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\series default
 [Acuña] We don't want to use mergesort since it requires creating an auxiliary
 array which doubles the space used.
 Mergesort is also bad because it requires stack memory for recursive calls.
\end_layout

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] What are the Big-Oh and Tilde orders of the following code fragment?
 The fragment is parametrized on the variable 
\begin_inset Formula $n$
\end_inset

.
 Assume that you are measuring the number of swap calls.
 [10 points] 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From FC15 final.
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public static void sort(Comparable[] a) {
\end_layout

\begin_layout Plain Layout

    int n = a.length;
\end_layout

\begin_layout Plain Layout

    for (int j = 0; j < n-1; j++) {
\end_layout

\begin_layout Plain Layout

        int z = j;
\end_layout

\begin_layout Plain Layout

        for (int i = j+1; i < n; i++) {
\end_layout

\begin_layout Plain Layout

            if (a[i] < a[z]) {
\end_layout

\begin_layout Plain Layout

                z = i;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if(z != j) {
\end_layout

\begin_layout Plain Layout

          swap(a[j], a[z]); //count these
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
What is the Big-Oh order of the above code fragment? If it does not exist,
 then explain.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [Acuña]
\end_layout

\begin_layout Standard
It is O(n) since it is inside one loop with linear incrementor.
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the Tilde order of the above code fragment? If it does not exist,
 then explain.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [Acuña]
\end_layout

\begin_layout Standard
It does not exist, swap only runs if z != j and we can't know how often
 that occurs without knowing the data.
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Short Answer: Mergesort
\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] If the merge() method from mergesort was used for merging queues,
 instead of arrays, how much space would be needed for auxiliary data storage?
 Assume the input is of length 
\emph on
n
\emph default
, and that all queues are internally implemented as a list.[5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
O(1) 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
O(logn)
\end_layout

\begin_layout Enumerate
O(n)
\end_layout

\begin_layout Enumerate
O(nlogn)
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Abraham] If you had to pick a data structure on which you would be performing
 merge sort, which one would you choose? (Hint: Think about minimizing space
 usage.) [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
Arrays
\end_layout

\begin_layout Enumerate
Linked Lists 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Priority Queue
\end_layout

\begin_layout Enumerate
Generics
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] In the lower bound proof for sorting, why must there be at least
 N! leaves on the decision tree? [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans: [Acuña]
\end_layout

\begin_layout Standard
A sorting algorithm must be able to sort (solve) any input.
 Given that the input is an array of size N, then there are N! permutations
 of it.
 Since each result is represented as a leaf, we need N! leaves to have enough
 solutions available for the possible inputs.
 This is the equivalent of saying that the tree contains a path which leads
 to the solution of each possible input.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Priority Queues 
\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] What is the difference between a (max) heap and a priority queue?
 [5 points]
\end_layout

\begin_deeper
\begin_layout Enumerate
A max heap provides ways to both add and remove elements, but a priority
 queue does not.
\end_layout

\begin_layout Enumerate
A priority queue requires O(n) time to remove an element, while a heap works
 in O(logn) time.
\end_layout

\begin_layout Enumerate
A heap is how data is structured, while saying priority queue specifies
 what operations can be performed.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
There isn't any difference, they're different names for the same thing.
\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
[Acuña] 
\series bold
Ans:
\series default
 A heap is a data structure and a priority queue is an ADT.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Abraham] Consider this array representation of a heap, what is the right
 child of node 75? Assume the zeroth index is null.
 A = {_, 100, 75, 50, 51, 40, 30, 3, 25, 10}
\end_layout

\begin_deeper
\begin_layout Enumerate
30
\end_layout

\begin_layout Enumerate
51
\end_layout

\begin_layout Enumerate
40 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
42
\end_layout

\begin_layout Enumerate
50
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
One of the main operations for a PQ is to move an element lower in a heap,
 so that it will be in the proper order.
 It is implemented by the sink() method.
 According to lecture, this particular implementation takes 
\begin_inset Formula $O(log(n))$
\end_inset

 number of exchanges to put the element in its proper place.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    private void sink(int k) {
\end_layout

\begin_layout Plain Layout

        while (2*k <= N) {
\end_layout

\begin_layout Plain Layout

            int j = 2*k;
\end_layout

\begin_layout Plain Layout

            if (j < N && less(j, j+1))
\end_layout

\begin_layout Plain Layout

              j++;
\end_layout

\begin_layout Plain Layout

            if (!less(k, j))
\end_layout

\begin_layout Plain Layout

              break;
\end_layout

\begin_layout Plain Layout

            exch(k, j);
\end_layout

\begin_layout Plain Layout

            k = j;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Support this claim by explaining why this method is 
\begin_inset Formula $O(log(n))$
\end_inset

: [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
The height of the tree will be 
\emph on

\begin_inset Formula $log_{2}(n)$
\end_inset


\emph default
, where 
\emph on
n
\emph default
 is the number of nodes, so since each loop iteration moves down one level,
 it can run a maximum of 
\begin_inset Formula $log_{2}(n)$
\end_inset

 times.
\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Symbol Tables
\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Consider the following scenario: you need to store a record for
 each of the top 1000 teams that participated in a machine learning competition,
 in order to be able to look up which team placed in a specific place.
 Would it make more sense to use an array or a symbol table for this problem?
 Explain.
 [5 points] 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
FA19
\end_layout

\end_inset

 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
M03_01::LO2
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
An array will probably be better.
 It will be faster and more efficient in storage.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
An array will probably be better.
 It will allow the team record type to be stored properly.
\end_layout

\begin_layout Enumerate
A symbol table will probably be better.
 It will provide more flexibility.
\end_layout

\begin_layout Enumerate
A symbol table will probably be better.
 It will be more efficient in storage.
\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Trace an initially empty symbol table (called ST) through the following
 operations:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SymbolTable<> ST = new BinarySearchTree<String, Integer>();
\end_layout

\begin_layout Plain Layout

ST.put("CSE110", 150);
\end_layout

\begin_layout Plain Layout

ST.put("CSE205", 150);
\end_layout

\begin_layout Plain Layout

ST.put("CSE230", 100);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 100);
\end_layout

\begin_layout Plain Layout

System.out.println(ST.get("CSE205"));
\end_layout

\begin_layout Plain Layout

ST.put("CSE205", 250);
\end_layout

\begin_layout Plain Layout

ST.put("SER316", 75);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give the contents of the symbol table after the code has been executed.
 Use the format ABC### : ### (e.g., 
\begin_inset Quotes eld
\end_inset

CSE110 : 150
\begin_inset Quotes erd
\end_inset

) to give your answer.
 Use separate lines for each key/value pair.
 [10 points]
\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SER100 : 150
\end_layout

\begin_layout Plain Layout

SER200 : 250
\end_layout

\begin_layout Plain Layout

SER250 : 100
\end_layout

\begin_layout Plain Layout

SER316 : 75
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Analysis, Design, and Justification II
\end_layout

\end_deeper
\begin_layout Enumerate
TODO [5 points] 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Suppose that we design a program that appears to successfully solve
 a problem, can we skip analysis and jump straight to justification? [5
 points] 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
SC20
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Yes - analysis only supports design, and design only supports justification.
\end_layout

\begin_layout Enumerate
Yes - this is what we already do for homework in classes.
\end_layout

\begin_layout Enumerate
No - the program needs more testing to check its apparent successfulness.
\end_layout

\begin_layout Enumerate
No - we wouldn't be clear on what makes a good solution.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Consider the following problem statement: find every pair of students
 in a textfile that share the first name.
 Give two reasonable assumptions that would be useful for solving this problem.
 (If needed, you may explain why an assumption would be useful.) [10 points]
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
SC20
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programming: Priority Queues
\end_layout

\begin_layout Standard

\emph on
The real exam will involve writing code for one or more methods.
 Methods typically contain ~20 lines and have a higher weight (20-30 points)
 than other questions.
 The problem given here uses linked lists but all modules with programming
 concepts are fair game (mergesort, priority queues, symbol tables).
\end_layout

\begin_layout Standard
Implement a method to find the k-th largest element in an array of size
 N using a minimum priority queue (MinPQ).
 Assume that the MinPQ class has a constructor that takes a single integer
 representing its maximum size, a insert(), a min(), a delMin(), an isEmpty(),
 and size() methods.
 The MinPQ does not resize (to preserve O(logn performance).
 You may not import any packages.
 Creating additional helper methods is fine but you should provide a one
 line comment that indicates their purpose.
 [20 points]
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

public int findKthLargest(int[] data, int k) {
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Extra Questions
\end_layout

\begin_layout Standard
The following questions were used on previous practice exams - they are
 not part of the practice exam, and may use content not covered in the current
 semester, but are provided for additional practice.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Formula $\;\;\;\;$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Mergesort
\end_layout

\begin_layout Enumerate
[Abraham] Which of the following arrays would insertion sort process the
 fastest? [5 points]
\end_layout

\begin_deeper
\begin_layout Standard
(a) {1, 2, 3, 4, 7, 5, 6}
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(b) {2, 3, 4, 6, 1, 5, 7}
\end_layout

\begin_layout Standard
(c) {6, 7, 5, 4, 3, 2, 1}
\end_layout

\begin_layout Standard
(d) They will be processed the same
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] Consider the following array: 23, 7, 35, 3, 4, 2, 13, 1.
 Show a trace of execution for top-down mergesort.
 Illustrate how the array is broken down, and then merged into an ordered
 state.
 [10 points]
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset VSpace 5cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
[23, 7, 35, 3, 4, 2, 13, 1]
\end_layout

\begin_layout Standard
[[23, 7, 35, 3], [4, 2, 13, 1]]
\end_layout

\begin_layout Standard
[[[23, 7], [35, 3]], [[4, 2], [13, 1]]]
\end_layout

\begin_layout Standard
[[[[23], [7]], [[35], [3]]], [[[4], [2]], [[13], [1]]]]
\end_layout

\begin_layout Standard
[[[7, 23], [3, 35]], [[2, 4], [1, 13]]]
\end_layout

\begin_layout Standard
[[3, 7, 23, 35], [1, 2, 4, 13]]
\end_layout

\begin_layout Standard
[1, 2, 3, 4, 7, 13, 23, 35]
\end_layout

\begin_layout Standard
\begin_inset VSpace 6cm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Priority Queues
\end_layout

\end_deeper
\begin_layout Enumerate
[Abraham] As mentioned in class, a max heap would be a great data structure
 when we need to extract the maximum element.
 Let us say that you are given a few processes that require CPU time which
 are stored in a heap structure.
 The process with minimum priority needs to be executed first.
 Example, a process with priority 0 needs to be picked up before a process
 with priority 1.
 We need to select the task with minimum priority.
 What would be the complexity to simply read the minimum element in a min
 heap? [5 points]
\end_layout

\begin_deeper
\begin_layout Standard
(a) O(1) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ANS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(b) O(logn)
\end_layout

\begin_layout Standard
(c) O(nlogn)
\end_layout

\begin_layout Standard
(d) O(n)
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard

\series bold
Short Answer: Symbol Tables
\end_layout

\end_deeper
\begin_layout Enumerate
Consider the task of implementing a SymbolTable vs an OrderedSymbolTable.
 For the purposes of get and put, which you be more likely to create an
 efficient implementation for? Explain.
 (Hint: no knowledge of BSTs or hash tables is needed.) [10 points]
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset VSpace 4cm
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard

\series bold
Ans:
\end_layout

\begin_layout Standard
OrderedSymbolTable offers more potential for optimization since it means
 you have some structure (i.e., all elements are Comparable) on the data which
 you can exploit.
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
